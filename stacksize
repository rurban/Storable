#!/usr/bin/perl
# binary search maximum stack depth for arrays and hashes
# and store it in stacksize.h

my $f;
my $fn = "stacksize.h";
if (open $f, "<", $fn) {
    my $s = <$f>;
    if ($s =~ /bisected/) {
        print "already bisected\n";
        exit;
    }
    close $f;
}

my ($n, $good, $bad, $found) =
    (35000, 100, 40000, undef);
my $try = '$t=[$t]';
print "probe for max. stack sizes...\n";

sub cmd {
    my $i = shift;
    die unless $i;
    "\"$^X\" -Mblib -MStorable=dclone -e'my \$t; $try for 1..$i; dclone(\$t);'";
}
# try more
sub good {
    my $i = shift; # this passed
    my $j = $i + abs(int(($bad - $i) / 2));
    print "$i passed, try more $j ...\n";
    $good = $i;
    if ($j <= $i) {
        $found++;
    }
    return $j;
}
# try less
sub bad {
    my $i = shift; # this failed
    my $j = $i - abs(int(($i - $good) / 2));
    print "$i failed, try less $j ...\n";
    $bad = $i;
    if ($j >= $i) {
        $j = $good;
        $found++;
    }
    return $j;
}

while (!$found) {
    if (system(cmd($n)) == 0) {
        $n = good($n);
    } else {
        $n = bad($n);
    }
}
print "MAX_DEPTH = $n\n";
my $max_depth = $n;

($n, $good, $bad, $found) =
    (18000, 50, 40000, undef);
$try = '$t={1=>$t}';
while (!$found) {
    if (system(cmd($n)) == 0) {
        $n = good($n);
    } else {
        $n = bad($n);
    }
}
print "MAX_DEPTH_HASH = $n\n";
my $max_depth_hash = $n;

open $f, ">", $fn;
print $f "/* bisected with stacksize.pl */\n";
print $f "#define MAX_DEPTH	 $max_depth\n";
print $f "#define MAX_DEPTH_HASH $max_depth_hash\n";
close $f;
